;;-*-Lisp-*-
(in-package goal)

;; name: mod-common-functions.gc
;; name in dgo: mod-common-functions
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file is a place where you can define custom functions and GOAL code
 to call inside of mod-custom-code.gc for example I have defined a function that increases
 the powercell count by one when it is called
 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Variables to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; teamrun
(define *teamrun-info* (new 'global 'teamrun-player-info))
(define *teamrun-levels-info* (new 'global 'game-levels-info))

(define *task-update-buffer* (new 'global 'boxed-array task-info MAX_TASK_BUFFER_COUNT))
(define *money-update-buffer* (new 'global 'boxed-array money-info MAX_MONEY_BUFFER_COUNT))
(define *crate-update-buffer* (new 'global 'boxed-array crate-info MAX_CRATE_BUFFER_COUNT))

(define *has-none-position-update?* #f)
(define *allow-cell-pickup?* #t)
(define *allow-zoomer-use?* #t)
(define *allow-final-boss?* #t)


;; multiplayer
(define *multiplayer-info* (new 'global 'multiplayer-info))
(define *remote-targets* (new 'global 'boxed-array handle MAX_MULTIPLAYER_COUNT))
(define *enable-remote-target-attacks* #f)
(define *enable-remote-target-yellow-eco-blasts* #f)
(define *enable-remote-target-pvp-attacks* #f)
(define *pvp-attack-sphere-size* 3000.0)

(define *self-player-info* (the-as remote-player-info #f))


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Functions to call in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun color-target-rgb ((tgt process-drawable) (r float) (g float) (b float))
  (set! (-> tgt draw color-mult r) r)
  (set! (-> tgt draw color-mult g) g)
  (set! (-> tgt draw color-mult b) b)
  (none)
  )

(defun target-on-racer? ((t target))
  (logtest? (-> t control root-prim prim-core action) (collide-action racer))
)

(defun target-on-flut? ((t target))
  (logtest? (-> t control root-prim prim-core action) (collide-action flut))
)

(defun target-on-foot? ((t target))
  (not (or 
        (logtest? (-> t control root-prim prim-core action) (collide-action racer)) 
        (logtest? (-> t control root-prim prim-core action) (collide-action flut)))
  )
)

(defun is-grabbed? ()
  (logtest? (-> *target* state-flags)
    (state-flags grabbed)
    )
  )

(defun color-target ((tgt process-drawable) (color tgt-color))
  (case color
    (((tgt-color normal))
      (color-target-rgb tgt 1.0 1.0 1.0)
      )
    (((tgt-color white))
      (color-target-rgb tgt 10.0 10.0 10.0)
      )
    (((tgt-color black))
      (color-target-rgb tgt 0.1 0.1 0.1)
      )
    (((tgt-color red))
      (color-target-rgb tgt 0.8 0.2 0.2)
      )
    (((tgt-color green))
      (color-target-rgb tgt 0.0 1.2 0.0)
      )
    (((tgt-color blue))
      (color-target-rgb tgt 0.0 0.5 2.0)
      )
    (((tgt-color yellow))
      (color-target-rgb tgt 1.5 1.5 0.0)
      )
    (((tgt-color purple))
      (color-target-rgb tgt 0.7 0.2 2.0)
      )
    (((tgt-color pink))
      (color-target-rgb tgt 1.0 0.0 1.0)
      )
    (((tgt-color light-blue))
      (color-target-rgb tgt 0.0 1.0 1.0)
      )
    ;; (((tgt-color holo))
    ;;   (color-target-rgb tgt 
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0))
    ;;   )
    )
  )


(defun set-up-self-remote-if-null ()
  (when (not *self-player-info*)
    (set! *self-player-info* (new 'global 'remote-player-info))
    (set! (-> *self-player-info* username) "local_player") 
    (set! (-> *self-player-info* color)  (tgt-color red))
    (set! (-> *self-player-info* mp_state)  (mp-tgt-state mp-tgt-connected))
    (set! (-> *multiplayer-info* player_num) 0)

    (dotimes (idx (-> *task-update-buffer* length))
      (set! (-> *task-update-buffer* idx) (new 'global 'task-info))
      )

    (dotimes (idx (-> *money-update-buffer* length))
      (set! (-> *money-update-buffer* idx) (new 'global 'money-info))
      )

    (dotimes (idx (-> *crate-update-buffer* length))
      (set! (-> *crate-update-buffer* idx) (new 'global 'crate-info))
      )

    (pc-connect-mp-info *multiplayer-info* *self-player-info* *teamrun-info* *teamrun-levels-info*)
    )
  (none)
)

(defun mark-repl-connected ()
    (send-event *target* 'loading)
    (set! (-> *self-player-info* color)  (tgt-color normal))
    (set! (-> *pc-settings* ps2-actor-vis?) #f)
    (pc-acknowledge-repl-connection)
  )

(defun update-self-multiplayer-info ()
  (set! (-> *self-player-info* trans_x)    (-> *target* root trans x))
  (set! (-> *self-player-info* trans_y)    (-> *target* root trans y))
  (set! (-> *self-player-info* trans_z)    (-> *target* root trans z))
  (set! (-> *self-player-info* quat_x)     (-> *target* root quat x))
  (set! (-> *self-player-info* quat_y)     (-> *target* root quat y))
  (set! (-> *self-player-info* quat_z)     (-> *target* root quat z))
  (set! (-> *self-player-info* quat_w)     (-> *target* root quat w))

  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    (set! (-> *self-player-info* zoomer_rot_y)     0.0)
    )

  (set! (-> *self-player-info* tgt_state)  (-> *target* state name))
  (set! (-> *self-player-info* active_tgt_state)  (-> *target* state name))

  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) username)   (-> *self-player-info* username))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) color)      (-> *self-player-info* color))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) zoomer_rot_y)     (-> *self-player-info* zoomer_rot_y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) tgt_state)  (-> *target* state name))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) active_tgt_state)  (-> *target* state name))
  (none)
  )

(defun update-debug-self-multiplayer-info ()
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) username)   "DEBUG")
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) color)      (tgt-color red))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) tgt_state)  (-> *target* state name))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) active_tgt_state)  (-> *target* state name))
  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    )
  (none)
  )


(defun target-sync-state ((tgt-state symbol) (t target))
  (case tgt-state
    ;; normal attacks (and relevant jumps) !DONE!
    (('target-running-attack) (go-process t target-running-attack))
    (('target-attack) (go-process t target-attack))
    (('target-attack-air) (go-process t target-attack-air #f))
    (('target-attack-uppercut) (go-process t target-attack-uppercut (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-attack-uppercut-jump) (go-process t target-attack-uppercut-jump (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-flop) (go-process t target-flop (the-as float 33775.48) (the-as float -122880.0)  (the-as float 0.0))) ;;ground pound
    (('target-flop-hit-ground) (go-process t target-flop-hit-ground #f))
    (('target-wheel) (go-process t target-wheel))
    (('target-wheel-flip) (go-process t target-wheel-flip (-> *TARGET-bank* wheel-flip-height) (-> *TARGET-bank* wheel-flip-dist)))
    
    ;; jumps !DONE!
    (('target-jump) (go-process t target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f)))
    (('target-double-jump) (go-process t target-double-jump (-> *TARGET-bank* double-jump-height-min) (-> *TARGET-bank* double-jump-height-max)))
    (('target-high-jump) (go-process t target-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'flip))
    (('target-duck-high-jump) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))
    (('target-duck-high-jump-jump) (go-process t target-duck-high-jump-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))

    ;; eco !DONE!
    (('target-eco-powerup) (send-event t 'powerup))
    (('target-yellow-blast) (go-process t target-yellow-blast))
    (('target-yellow-jump-blast) (go-process t target-yellow-jump-blast))
    (('target-launch) (go-process t target-launch (the-as float (-> t control unknown-dword60)) (the-as symbol (-> t control unknown-dword61)) (-> t control unknown-vector102) (-> t control unknown-dword63)))

    ;; edge grabs !DONE!
    (('target-edge-grab) (go-process t target-edge-grab))
    (('target-edge-grab-off) (go-process t target-edge-grab-off))
    (('target-edge-grab-jump) (go-process t target-edge-grab-jump (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))
    (('target-jump-forward) (go-process t target-jump-forward (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))

    ;; normal movement
    (('target-stance) (go-process t target-stance))
    (('target-stance-ambient) (go-process t target-stance-ambient))
    (('target-stance-look-around) (go-process t target-stance-look-around))
    (('target-walk) (go-process t target-walk))
    (('target-wade-stance) (go-process t target-wade-stance))
    (('target-wade-walk) (go-process t target-wade-walk))
    (('target-ice-stance) (go-process t target-ice-stance))
    (('target-ice-walk) (go-process t target-ice-walk))
    (('target-load-wait) (go-process t target-load-wait)) ;; trip
    (('target-slide-down) (go-process t target-slide-down)) ;; slippery surface
    (('target-turn-around) (go-process t target-turn-around))
    (('target-falling) (go-process t target-falling #f))

    ;; hit !DONE!
    (('target-hit) (go-process t target-hit 'shove (-> t attack-info-rec)))
    (('target-hit-ground) (go-process t target-hit-ground #f))
    (('target-hit-ground-hard) (go-process t target-hit-ground-hard 0.0)) ;;toggle to 1.0 to flash invuln frames)

    ;; tube slide
    (('target-tube-start) (send-event t 'change-mode 'tube #f))
    (('target-tube) (go-process t target-tube))
    (('target-tube-jump) (go-process t target-tube-jump (-> *TARGET-bank* tube-jump-height-min) (-> *TARGET-bank* tube-jump-height-max)))
    ;;(('target-tube-hit) (go-process t target-hit-ground #f)

    ;; poles !TODO: crashes if *target* is in another level so the remote level isn't loaded
    ;; (('target-pole-cycle) (go-process t target-pole-flip-up 28672.0 28672.0 6000.0))
    ;; (('target-pole-flip-forward) (go-process t target-pole-flip-forward (the-as float 14336.0) (the-as float 14336.0) (the-as float 57344.0)))
    ;; (('target-pole-flip-forward-jump) (go-process t target-pole-flip-forward-jump (the-as float 14336.0) (the-as float 14336.0)))
    ;; (('target-pole-flip-up) (go-process t target-pole-flip-up 28672.0 28672.0 6000.0))
    ;; (('target-pole-flip-up-jump) (go-process t target-pole-flip-up-jump 28672.0 28672.0))

    ;; swiming & water
    (('target-swim-stance) (send-event t 'change-mode 'swim) (go-process t target-swim-stance))
    (('target-swim-walk) (send-event t 'change-mode 'swim) (go-process t target-swim-walk))
    (('target-swim-down) (go-process t target-swim-down))
    (('target-swim-up) (go-process t target-swim-up))
    (('target-swim-jump) (go-process t target-swim-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max)))
    (('target-swim-jump-jump) (go-process t target-swim-jump-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max) (the-as surface #f)))
   
    ;; duck !DONE!
    (('target-duck-stance) (go-process t target-duck-stance))
    (('target-duck-walk) (go-process t target-duck-walk))

    ;; warp gates !DONE!
    (('target-warp-out) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))
    (('target-warp-in) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))


    ;; other
    ;; (('target-clone-anim) (spool-push *art-control* "fuel-cell-victory" 0 t (the-as float -99.0)) (send-event t 'clone-anim t)) ;; powercell pickup
    (('target-fishing) (send-event t 'change-mode 'fishing #f))
    (('target-periscope) (send-event t 'change-mode 'periscope #f))
    (('target-grab) (go-process t target-grab)) ;; process-grab animation while in cutscenes

    ;; unknown
    (('target-look-around) (go-process t target-look-around))

    ;; redundant for multiplayer
    ;; (('target-death) (go-process t target-hit-ground-hard 0.0))
    ;; (('target-tube-death))
    ;; (('target-billy-game)) ;; will only put you in first person
    ;; (('target-play-anim))
    ;; (('target-snowball))
    ;; (('target-snowball-start))
    ;; (('target-title))
    ;; (('target-title-play))
    ;; (('target-title-wait))
    ;; (('target-continue))
    ;; (('target-demo))
    ;; (('target-startup))
    ;; (('target-final-door))


    ;; zoomer !DONE!
    (('target-racing 'target-racing-start 'target-racing-get-on 'target-racing-bounce 'target-racing-clone-anim 
      'target-racing-falling 'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack)
      
      (if (not (target-on-racer? t))
        (send-event t 'change-mode 'racing #f)
        )
      
      (when (target-on-racer? t) 
        (case tgt-state
          (('target-racing) (go-process t target-racing))
          (('target-racing-bounce) (go-process t target-racing-bounce 2048.0 2048.0 #f))
          (('target-racing-jump) (go-process t target-racing-jump 2048.0 5324.8 #t))
          (('target-racing-smack) (go-process t target-racing-smack (-> t control unknown-float01) #t))
          (('target-racing-grab) (go-process t target-racing-grab))
          (('target-racing-falling) (go-process t target-racing-falling))
          ;; (('target-racing-hit))
          ;; (('target-racing-clone-anim))
          )
        )
      )
    (('target-racing-get-off 'target-racing-get-off-hit-ground 'target-racing-get-off-jump 'target-racing-death)
      (if (target-on-racer? t)
          (send-event t 'end-mode)
        )
      )


    ;; flut flut !DONE!
    (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
      'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
      'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
      
      (if (not (target-on-flut? t))
        (send-event t 'change-mode 'flut #f)
        )

      (when (target-on-flut? t) 
        (case tgt-state
          (('target-flut-stance) (go-process t target-flut-stance))
          (('target-flut-walk) (go-process t target-flut-walk))
          (('target-flut-falling) (go-process t target-flut-falling #f))
          (('target-flut-running-attack) (go-process t target-flut-running-attack))
          (('target-flut-jump) (go-process t target-flut-jump (-> *FLUT-bank* jump-height-min) (-> *FLUT-bank* jump-height-max)))
          (('target-flut-double-jump) (go-process t target-flut-double-jump (-> *FLUT-bank* double-jump-height-min) (-> *FLUT-bank* double-jump-height-max)))
          (('target-flut-air-attack) (go-process t target-flut-air-attack (-> *FLUT-bank* air-attack-speed)))
          (('target-flut-air-attack-hit-ground) (go-process t target-flut-air-attack-hit-ground))
          (('target-flut-grab) (go-process t target-flut-grab))
          (('target-flut-hit) (go-process t target-flut-hit 'shove (-> t attack-info-rec)))
          (('target-flut-hit-ground) (go-process t target-flut-hit-ground ))
          ;; (('target-flut-clone-anim))
          )
      )
      )
    (('target-flut-get-off 'target-flut-get-off-hit-ground 'target-flut-get-off-jump 'target-flut-death)
      (if (target-on-flut? t)
          (send-event t 'end-mode)
        )
      )

    )
  (none)
  )

(defun update-actor-position ((obj process-drawable) (p remote-player-info))
  ;; position
  (set! (-> obj root trans x) (-> p trans_x))
  (set! (-> obj root trans y) (-> p trans_y))
  (set! (-> obj root trans z) (-> p trans_z))
  ;; rotation
  (set! (-> obj root quat x)  (-> p quat_x))
  (set! (-> obj root quat y)  (-> p quat_y))
  (set! (-> obj root quat z)  (-> p quat_z))
  (set! (-> obj root quat w)  (-> p quat_w))

  (color-target obj (-> p color))

  ;; additional steps for rotation, state, etc
  (case (-> obj type)
    ((target)
      (let* ((t (the target obj)))

        (if (target-on-racer? t)
          (set! (-> t racer rot y) (-> p zoomer_rot_y))
          )

        ;; draw usernames for all players
        (add-debug-text-3d
                      #t
                      (bucket-id subtitle)
                      (-> p username)
                      (-> t root trans)
                      (font-color white)
                      (new 'static 'vector2h :y 16)
                      )

        ;; activate nuka glitch for other targets
        (logior! (-> t state-flags) (state-flags dying))

        ;; finalize rotation
        (quaternion-copy! (-> t control dir-targ) (-> t root quat))
          
        ;; sync target state
        (when (!= (-> p active_tgt_state) (-> p tgt_state))
          (set! (-> p active_tgt_state) (-> p tgt_state))
          (target-sync-state (-> p tgt_state) t)
          )
        )
      )
    ((money)
      (let ((m (the money obj)))
        (vector-copy! (-> m base) (-> m root trans))
        (vector-copy! (-> m root-override root-prim world-sphere) (-> m root trans))
        )
      )
    )
    (none)
  )

(defun start-extra-target ()
  (ppointer->handle (process-spawn
                target
                :init init-target
                  (-> *game-info* current-continue)
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                ))
  )

(defun render-targets ()
 (dotimes (idx MAX_MULTIPLAYER_COUNT)
    (when (!= (-> *multiplayer-info* player_num) idx)
      (when (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
        ;; see if we need to spawn any remote targets
        (when (or (zero? (-> *remote-targets* idx)) (not (handle->process (-> *remote-targets* idx))))
          (set! (-> *remote-targets* idx) (start-extra-target))
          )
        ;; assume target spawned at this point 

        ;; position/color remote targets
        (let ((p (-> *multiplayer-info* players idx))
              (obj (the process-drawable (handle->process (-> *remote-targets* idx)))))
          (when obj
            (update-actor-position obj p)
            )
          )
        )
      )
    ) 
  )


(defun get-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


;; Macros can be used more-or-less just like functions
(defmacro current-cell-count ()
  `(-> *game-info* fuel)
  )

(defmacro set-current-cell-count (count)
  `(set! (-> *game-info* fuel) ,count)
  )
  
(defun increase-power-cell-by-one ()
  (set-current-cell-count (+ (current-cell-count) 1))
  ;; with the two macros defined above, this is equivalent to
  ;; (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Approved Custom Functions/Macros to call in all mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; These are included with the mod base and you are welcome to use them in your mods!

(defmacro current-checkpoint-name ()
  `(-> *game-info* current-continue name)
  )

(defun set-current-checkpoint-by-name ((name string))
  (set-continue! *game-info* name)
  )

(defmacro current-level-name ()
  `(-> (level-get-target-inside *level*) name)
  )
  
(defmacro current-orb-count ()
  `(-> *game-info* money)
  )

(defmacro current-cutscene ()
  `(-> *art-control* active-stream)
  )

;;This function moves an actor to the given coordinates
;;example: (move-actor "farmer-3" 3.0 74.0 -120.0)
(defun move-actor ((actor-name string) (x float) (y float) (z float))
  (when (entity-by-name actor-name)
    (let* ((entity-actor (entity-by-name actor-name))
           (actor (-> entity-actor extra process))
           )
      (when actor
        (case (-> actor type)
          ((fuel-cell)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
            (when (name= (-> (the fuel-cell actor) state name) 'wait)
              ;; only move collision when idle (messes up glowing in cutscene)
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((orb-cache-top)
            ;; don't move while its activated (let it go up/down)
            (when (not (name= (-> (the orb-cache-top actor) state name) 'orb-cache-top-activate))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) basetrans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere z) (meters z))
              (set-vector! (-> (the orb-cache-top actor) draw origin) (meters x) (meters y) (meters z) 1.0)
              (let ((radius (-> (the process-drawable actor) draw radius))
                    (bounds (res-lump-data entity-actor 'visvol (inline-array vector)))
                    )
                (set-vector! (-> bounds 0) (- (meters x) radius) (meters y) (- (meters z) radius) 1.0)
                (set-vector! (-> bounds 1) (+ (meters x) radius) (meters y) (+ (meters z) radius) 1.0)
                )
              )
            )
          ((money)
            ;; don't move orbs if being blue-eco-sucked
            (when (not (logtest? (-> (the money actor) flags) (collectable-flags suck)))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the money actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the money actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the money actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((crate crate-buzzer)
            ;; only move crates if they're not jumping
            (when (= (-> (the crate actor) smush amp) 0.0)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the crate actor) base) (meters x) (meters y) (meters z) 1.0)
              ;; (set-vector! (-> (the crate actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere x) (meters x))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere y) (meters y))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((darkvine)
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
          )
          (else
            (format 0 "unexpected actor type ~S ~S ~S~%" actor-name (-> entity-actor type) (-> actor type))
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
            )
          )
        )
      )
    )
  (none)
  )

(defun spawn-actor-by-name ((name string))
  ;; Takes in the string of name of a actor, and spawns a new process based on the entity.
    (let* ((entity-actor (the entity-actor (entity-by-name name)))
          (type (-> entity-actor etype))
          (e-info (entity-info-lookup type))
      )
      (when (entity-by-name name)
        (init-entity 
          (get-process *default-dead-pool* type (if e-info (-> e-info heap-size) #x4000)) 
          entity-actor)
          (sound-play "buzzer-pickup")
      )
      (if (not (entity-by-name name))
          (sound-play "oof")
      )
    )
    (none)
)

;;Draws a debug sphere on the actor, takes in a string actor name and a radius for the sphere in meters
(defun draw-debug-sphere-on-actor ((actorName string)(radius float))
  (when *debug-segment*
    (when (process-by-ename actorName)
      (add-debug-sphere #t (bucket-id debug)  (-> (the-as process-drawable (process-by-ename actorName)) root trans) (meters radius) (static-rgba 0 #xff 0 #x40))
    )
  )
  (none)
)


;;This function moves a given actor to jaks current position, then prints a (move-actors) call in gk.exe
(defun move-to-jak ((arg0 string))
(format #t "move-actor code:  (move-actor ~a ~m ~m ~m)~%" arg0(-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z))
  (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) crate)
    (begin
        (set! (-> (the crate (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )
  )
)

;; quick macro for setting vector xyz in meters, leaving w alone
(defmacro set-vector-meters! (dst x y z)
  `(set-vector! ,dst (meters ,x) (meters ,y) (meters ,z) (-> ,dst w))
  )

;; quick macro for constructing static vector with w=1
(defmacro static-vector-meters (x y z)
  `(new 'static 'vector :x (meters ,x) :y (meters ,y) :z (meters ,z) :w 1.0)
  )

;; prints vector xyz in meters
(defmacro print-vector-meters (vec &key (dst #t))
  `(format ,dst "~m ~m ~m~%" (-> ,vec x) (-> ,vec y) (-> ,vec z))
  )

;; takes a path-control and xyz values to offsets every node in the path by
(defmacro shift-path! (path x y z)
  `(let ((voff (static-vector-meters ,x ,y ,z)))
    (dotimes (idx (-> ,path num-cverts))
      (vector+! (-> ,path cverts idx) (-> ,path cverts idx) voff)
      )
    )
  )

;; prints all the nodes in a path in meters
(defmacro path-print-meters (path)
  `(dotimes (idx (-> ,path num-cverts))
    (print-vector-meters (-> ,path cverts idx))
    )
  )

;; prints the position (root trans) of a process-drawable
(defmacro pd-pos-m (procname)
  `(let* ((obj (the process-drawable (process-by-ename ,procname)))
          (vec (-> obj root trans)))
    (format 0 "~m ~m ~m~%" (-> vec x) (-> vec y) (-> vec z) 4096.0)
    (none)
    )
  )

;;This function moves an actor based on jaks position + an offset
(defun move-to-behind-jak ((arg0 string) (arg1 meters) (arg2 meters))
 (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-(-> (target-pos 0) x) (meters arg1)) (+ (-> (target-pos 0) y) (meters arg2)) (-(-> (target-pos 0) z)(meters arg1)) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
    (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
  )
)

;;This turns on play hints
(defun turnonplayhints ()
(set! (-> *setting-control* default play-hints) #t)
)

;;This turns off playhints
(defun turnoffplayhints()
(set! (-> *setting-control* default play-hints) #f)
)

;;This turns on collision render when called
(defun turnonCollisionmode()
  (set! *collision-renderer* #t)
  (logclear! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This turns off collision render when called
(defun turnoffCollisionmode()
  (set! *collision-renderer* #f)
  (logior! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This makes it thunder in the current level
(defun thunderTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village2)
  (set! (-> (level-get-target-inside *level*) mood) *village2-mood*)
)

;;This makes the current level dark when called
(defun DarkesetGlitchTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-finalboss )
  (set! (-> (level-get-target-inside *level*) mood) *finalboss-mood*)
)

;;This needs fixed
(defun rainyTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-swamp)
  (set! (-> (level-get-target-inside *level*) mood) *swamp-mood*)
)

;;This needs fixed
(defun snowingTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-snow)
  (set! (-> (level-get-target-inside *level*) mood) *snow-mood*)
)

;;This makes the current levels weather the same as village1
(defun defaultWeatherTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village1)
  (set! (-> (level-get-target-inside *level*) mood) *village1-mood*)
)

;;This moves jak to a provided coordinate example call
;;(tp-jak 0.0 12.0 32.32)
(defun tp-jak ((arg0 float)(arg1 float)(arg2 float))
  (set! (-> (target-pos 0) x) (meters arg0))
  (set! (-> (target-pos 0) y) (meters arg1))
  (set! (-> (target-pos 0) z) (meters arg2))
)

;;This returns true or false depending on if jak is within a provided distance from an actor
(defun close? ((actor-ename string) (dist float))
  (and 
    (process-by-ename actor-ename)
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> (the process-drawable (process-by-ename actor-ename)) root trans)
        )
      dist
      )
    )
  )


;;This returns true or false if jak is within a bubble defined by coordiantes and width
(defun in-bubble? ((x float) (y float) (z float) (w float))
  (<= 
    (vector-vector-distance 
      (target-pos 0) 
      (set-vector! (new-stack-vector0) x y z 1.0)
      )
    (/ w 2.0)
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Jak Color functions
;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun draw-xyz ((jak target) (x float) (y float) (z float))
  (set! (-> jak draw color-mult x) x)
  (set! (-> jak draw color-mult y) y)
  (set! (-> jak draw color-mult z) z)
)
(defun draw-normal ((jak target))
  (draw-xyz jak 1.0 1.0 1.0)
)
(defun draw-white ((jak target))
  (draw-xyz jak 3.5 3.5 3.5)
)
(defun draw-black ((jak target))
  (draw-xyz jak 0.1 0.1 0.1)
)
(defun draw-red ((jak target))
  (draw-xyz jak 0.8 0.2 0.2)
)
(defun draw-green ((jak target))
  (draw-xyz jak 0.0 1.2 0.0)
)
(defun draw-blue ((jak target))
  (draw-xyz jak 0.0 0.5 2.0)
)
(defun draw-yellow ((jak target))
  (draw-xyz jak 1.5 1.5 0.0)
)
(defun draw-pink ((jak target))
  (draw-xyz jak 1.0 0.0 1.0)
)
(defun draw-light-blue ((jak target))
  (draw-xyz jak 0.0 1.0 1.0)
)



