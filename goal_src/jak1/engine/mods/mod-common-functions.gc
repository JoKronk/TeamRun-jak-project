;;-*-Lisp-*-
(in-package goal)

;; name: mod-common-functions.gc
;; name in dgo: mod-common-functions
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file is a place where you can define custom functions and GOAL code
 to call inside of mod-custom-code.gc for example I have defined a function that increases
 the powercell count by one when it is called
 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Variables to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; teamrun
(define *teamrun-info* (new 'global 'teamrun-player-info))
(define *teamrun-levels-info* (new 'global 'game-levels-info))

(define *interaction-update-buffer* (new 'global 'boxed-array interaction-info MAX_INTERACTION_BUFFER_COUNT))
(define *last-task* (game-task none)) ;; tasks get closed twice in a row sometimes, this is used to prevent it from sending multiple of same close over socket
(define *last-task-status* (task-status invalid))

(define *allow-cell-pickup?* #t)
(define *allow-final-boss?* #t)
(define *has-none-position-update?* #f)

;; game settings
(define *enable-ingame-cutscenes?* #f)

;; multiplayer
(define *multiplayer-info* (new 'global 'multiplayer-info))
(define *remote-targets* (new 'global 'boxed-array handle MAX_MULTIPLAYER_COUNT))
(define *remote-target-active-count* 0)

;; multiplayer settings
(define *enable-remote-target-attacks* #t)
(define *enable-remote-target-yellow-eco-blasts* #t)
(define *enable-remote-target-pvp-attacks* #f)
(define *pvp-attack-sphere-size* 3000.0)

;; pickup toggles for remote
(define *enable-remote-target-eco-pickup* #f) ;; recommended to be #f and instead controlled by position data interactions so that the physical target can't accidentally miss it
(define *enable-remote-target-buzzer-pickup* #f) ;; recommended to be #f and instead controlled by position data interactions so that cell fly can't drop two cells on pickup

;; multiplayer self
(define *self-player-info* (the-as remote-player-info #f))


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Functions to call in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun color-target-rgb ((tgt process-drawable) (r float) (g float) (b float))
  (set! (-> tgt draw color-mult r) r)
  (set! (-> tgt draw color-mult g) g)
  (set! (-> tgt draw color-mult b) b)
  (none)
  )

(defun target-on-racer? ((t target))
  (logtest? (-> t control root-prim prim-core action) (collide-action racer))
)

(defun target-on-flut? ((t target))
  (logtest? (-> t control root-prim prim-core action) (collide-action flut))
)

(defun target-on-foot? ((t target))
  (not (or 
        (logtest? (-> t control root-prim prim-core action) (collide-action racer)) 
        (logtest? (-> t control root-prim prim-core action) (collide-action flut)))
  )
)

(defun is-grabbed? ()
  (logtest? (-> *target* state-flags)
    (state-flags grabbed)
    )
  )

(defun is-interactive? ((tgt-idx int))
  (= (-> *multiplayer-info* players tgt-idx mp_state) (mp-tgt-state mp-tgt-interactive))
  )

(defun safe-deactivate-remote-target ((idx int))
  (let* ((remote-target (-> *remote-targets* idx)))
    (when (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
      (set! (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
      (deactivate (handle->process remote-target))
      )
    )
  )

  (defun safe-deactivate-remote-cell ()
    (let* ((remote-cell (process-by-name "remote-cell" *active-pool*)))
      (when remote-cell
        (deactivate remote-cell)
      )
    )
  )

    (defun safe-break-crate ((crate-name string))
    (let* ((obj-crate (process-by-ename crate-name)))
      (when obj-crate
        (if (not (or (name= (-> (the-as crate obj-crate) state name) "die") (name= (-> (the-as crate obj-crate) state name) "special-contents-die")))
          (go-virtual-process (the-as crate obj-crate) die #f 0)
          )
        )
      )
      (none)
      )

    (defun safe-kill-orb ((money-name string))
      (process-entity-status! (the-as money (process-by-ename money-name)) (entity-perm-status dead) #t)
      (kill-by-name money-name *active-pool*)
      )

    (defun safe-kill-cache-orb ((cache-name string))
      (let* ((orb-cache (the-as orb-cache-top (process-by-ename cache-name))))
        (when (-> orb-cache state)
          (case (-> orb-cache state)
            ((orb-cache-top-activate)
              (if (and (>= (- (-> orb-cache money) 1) 0) (handle->process (-> orb-cache money-list (- (-> orb-cache money) 1))))
                (deactivate (handle->process (-> orb-cache money-list (- (-> orb-cache money) 1))))
                )
              )
            ((orb-cache-top-idle)
              (when (>= (- (-> orb-cache money) 1) 0)
                (set! (-> orb-cache money) (- (-> orb-cache money) 1))
                (set! (-> orb-cache entity extra perm user-int16 0) (- 15 (-> orb-cache money)))
                )
              )
            )
          )
          (when (and orb-cache (<= (-> orb-cache money) 0))
            (process-entity-status! orb-cache (entity-perm-status complete) #f)
            (go-process orb-cache orb-cache-top-complete #t)
            )
        )
        (none)
      )

    (defun safe-kill-crate-orb ((crate-name string))
      (let* ((obj-crate (process-by-ename crate-name)))

        (when (name= (-> (the-as crate obj-crate) state name) "wait")
          (set! (-> (the-as crate obj-crate) fact pickup-amount) (- (-> (the-as crate obj-crate) fact pickup-amount) 1))
          (when (<= (-> (the-as crate obj-crate) fact pickup-amount) 0)
            (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status bit-4) #f)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status complete) #t)
            ((method-of-type crate deactivate) (the-as crate obj-crate))
            )
          (return #t)
          )

        (when (name= (-> (the-as crate obj-crate) state name) "special-contents-die") ;; when in orb collect phase

          (when (>= (-> (the-as crate obj-crate) entity extra perm user-int8 0) 1) ;; all orbs have not been collected

            (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) (+ (-> (the-as crate obj-crate) entity extra perm user-int8 1) 1))
            (+! (-> (the-as crate obj-crate) child-count) -1)

            ;; depspawn orb if exists
            (if (-> (the-as crate obj-crate) child 0)
              ((method-of-type money deactivate) (the-as money (-> (the-as crate obj-crate) child 0)))
              )

            ;; mark as completed if done
            (when (or (= (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0) (= (-> (the-as crate obj-crate) entity extra perm user-int8 1) (float->int (-> (the-as crate obj-crate) fact pickup-amount)))) ;; if no orbs are left
                (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status bit-4) #f)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status complete) #t)
                ((method-of-type crate deactivate) (the-as crate obj-crate))
              )
            )
          )
        )
        (none)
      )

    (defun safe-kill-crate-buzzer ((crate-name string) (run-pickup symbol) (kill-if-not-buzzer symbol))
      (let* ((obj-crate (process-by-ename crate-name))
            (is-cell-buzzer #f)) ;; swap to check if cell buzzer so it checks programatically if the count is 7

        (when (and run-pickup obj-crate (-> (the-as crate obj-crate) child 0))
          (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)

          (let* ((buzzer (the-as buzzer (-> (the-as crate obj-crate) child 0)))
                (s5-2 (logand (the int (-> buzzer fact pickup-amount)) #xffff))
                (s4-1 (get-task-control (the-as game-task s5-2)))
                )

            (go-virtual-process buzzer pickup #f (process->handle buzzer))
            
            (when (and (= (get-reminder s4-1 0) 127) (and (-> buzzer entity) (not (task-complete? *game-info* (the-as game-task s5-2)))))
              (set! is-cell-buzzer #t)
              )
            )
          )

        ;; depspawn buzzer if exists
        (if (and obj-crate kill-if-not-buzzer (not is-cell-buzzer) (name= (-> (the-as crate obj-crate) state name) "special-contents-die") (-> (the-as crate obj-crate) child 0))
          ((method-of-type buzzer deactivate) (the-as buzzer (-> (the-as crate obj-crate) child 0)))
          )
        ;; depspawn crate
        (if (and obj-crate (not is-cell-buzzer) (name= (-> (the-as crate obj-crate) state name) "wait"))
          ((method-of-type crate deactivate) (the-as crate obj-crate))
          )

        )
        (none)
      )

    (defun safe-kill-fuel-cell ((cell-name string))
      (process-entity-status! (the-as fuel-cell (process-by-ename cell-name)) (entity-perm-status dead) #t)
      (kill-by-name cell-name *active-pool*)
      )

    (defun safe-pickup-crate-eco ((crate-name string))
      (let* ((obj-crate (process-by-ename crate-name)))

        (if (name= (-> (the-as crate obj-crate) state name) "wait")
          (safe-break-crate crate-name)
          )

        ;; pickup eco if exists
        (when (and (name= (-> (the-as crate obj-crate) state name) "special-contents-die") (-> (the-as crate obj-crate) child 0))
          (go-virtual-process (the-as eco-collectable (-> (the-as crate obj-crate) child 0)) pickup #f (the-as handle #f))
          )
        )
        (none)
      )

    (defun safe-pickup-eco ((eco-ename string))
      (let* ((obj-eco (process-by-ename eco-ename)))
        (when (-> obj-eco name)
          (go-virtual-process (the-as eco-collectable obj-eco) pickup #f (process->handle (the-as eco-collectable obj-eco)))
          )
        )
        (none)
      )

    (defun remove-money-dupe-from-level ((level string))
      (send-event *target* 'get-pickup 5 -1.0)
      ;; get the level index
      (let ((level-idx (-> *level-task-data-remap* (+ (-> (lookup-level-info (string->symbol level)) index) -1))))
        ;; decrease the level money count
        (+! (-> *target* game money-per-level level-idx) -1)
        ;; increment our total money in the game (out of the 2000 max orbs)
        (+! (-> *target* game money-total) -1.0)
        )
        (none)
      )

    (defun give-money-from-level ((level string))
      (pickup-collectable! (-> *target* fact-info-target) (pickup-type money) 1.0 (process->handle (-> (-> *target* fact-info-target) process)))
      ;; get the level index
      (let ((level-idx (-> *level-task-data-remap* (+ (-> (lookup-level-info (string->symbol level)) index) -1))))
        ;; increment the level money count
        (+! (-> *target* game money-per-level level-idx) 1)
        ;; increment our total money in the game (out of the 2000 max orbs)
        (+! (-> *target* game money-total) 1.0)
        ;; if we have all the money in our level, display the all orbs graphic
        (if (= (-> *target* game money-per-level level-idx) (-> (get-game-count level-idx) money-count))
            (activate-orb-all level-idx)
            )
        )
        (none)
      )

    (defun give-buzzer-from-level ((buzzer-id float) (level string))
        (cond
          ((name= (-> (level-get-target-inside *level*) name) level)
            (pickup-collectable! (-> *target* fact-info-target) (pickup-type buzzer) buzzer-id (process->handle *target*))
            )
          (else
            (adjust (-> *target* game) 'buzzer buzzer-id (process->handle *target*))
            (sound-play "cursor-options")
            )
          )
          (none)
      )

    (defun give-fuel-cell ((cell-name string) (task game-task))
      (dm-give-cell task)
      (safe-kill-fuel-cell cell-name)
      )

    (defun safe-give-eco-by-target-idx ((idx int) (type int) (amount float))
      (let ((target (get-interactive-target idx)))
        (send-event target 'get-pickup type amount)
        )
      )

    (defun safe-release-from-grab ()
      (when (is-grabbed?)
        (process-release? *target*)
        )
      )

  (defun run-target-fuel-cell-pickup ((remote-target target))
    (when (process-close? remote-target 500000.0) ;; only run if *target* is close enough as pickup sound is global
      (let* ((remote-cell (birth-pickup-at-point (-> remote-target control trans) (pickup-type fuel-cell) 1.0 #f remote-target (the-as fact-info #f))))
        (safe-deactivate-remote-cell)
        (set! (-> (the-as fuel-cell (ppointer->process remote-cell)) name) "remote-cell")
        (go-virtual-process (the-as fuel-cell (ppointer->process remote-cell)) pickup #f (process->handle remote-target))
      )
    )
    (none)
    )

(defun color-target ((tgt process-drawable) (color tgt-color))
  (case color
    (((tgt-color normal))
      (color-target-rgb tgt 1.0 1.0 1.0)
      )
    (((tgt-color white))
      (color-target-rgb tgt 10.0 10.0 10.0)
      )
    (((tgt-color black))
      (color-target-rgb tgt 0.1 0.1 0.1)
      )
    (((tgt-color red))
      (color-target-rgb tgt 0.8 0.2 0.2)
      )
    (((tgt-color green))
      (color-target-rgb tgt 0.0 1.2 0.0)
      )
    (((tgt-color blue))
      (color-target-rgb tgt 0.0 0.5 2.0)
      )
    (((tgt-color yellow))
      (color-target-rgb tgt 1.5 1.5 0.0)
      )
    (((tgt-color purple))
      (color-target-rgb tgt 0.7 0.2 2.0)
      )
    (((tgt-color pink))
      (color-target-rgb tgt 1.0 0.0 1.0)
      )
    (((tgt-color light-blue))
      (color-target-rgb tgt 0.0 1.0 1.0)
      )
    ;; (((tgt-color holo))
    ;;   (color-target-rgb tgt 
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0))
    ;;   )
    )
  )


(defun set-up-self-remote-if-null ()
  (when (not *self-player-info*)
    (set! *self-player-info* (new 'global 'remote-player-info))
    (set! (-> *self-player-info* username) "local_player") 
    (set! (-> *self-player-info* color)  (tgt-color red))
    (set! (-> *self-player-info* mp_state)  (mp-tgt-state mp-tgt-interactive))
    (set! (-> *multiplayer-info* player_num) 0)

    (dotimes (idx (-> *interaction-update-buffer* length))
      (set! (-> *interaction-update-buffer* idx) (new 'global 'interaction-info))
      )

    (pc-connect-mp-info *multiplayer-info* *self-player-info* *teamrun-info* *teamrun-levels-info*)
    )
  (none)
)

(defun mark-repl-connected ()
    (send-event *target* 'loading)
    (set! (-> *self-player-info* color)  (tgt-color normal))
    (set! (-> *pc-settings* ps2-actor-vis?) #f)
    (pc-acknowledge-repl-connection)
  )

(defun update-self-multiplayer-info ()
  (set! (-> *self-player-info* trans_x)    (-> *target* root trans x))
  (set! (-> *self-player-info* trans_y)    (-> *target* root trans y))
  (set! (-> *self-player-info* trans_z)    (-> *target* root trans z))
  (set! (-> *self-player-info* quat_x)     (-> *target* root quat x))
  (set! (-> *self-player-info* quat_y)     (-> *target* root quat y))
  (set! (-> *self-player-info* quat_z)     (-> *target* root quat z))
  (set! (-> *self-player-info* quat_w)     (-> *target* root quat w))

  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    (set! (-> *self-player-info* zoomer_rot_y)     0.0)
    )

  (set! (-> *self-player-info* tgt_state)  (-> *target* state name))

  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) username)   (-> *self-player-info* username))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) color)      (-> *self-player-info* color))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) zoomer_rot_y)     (-> *self-player-info* zoomer_rot_y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) tgt_state)  (-> *target* state name))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) inter_type)     (-> *self-player-info* inter_type))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) inter_amount)   (-> *self-player-info* inter_amount))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) inter_name)     (-> *self-player-info* inter_name))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) inter_parent)   (-> *self-player-info* inter_parent))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) inter_level)   (-> *self-player-info* inter_level))
  (none)
  )

(defun update-debug-self-multiplayer-info ()
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) username)   "DEBUG")
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) color)      (tgt-color red))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) tgt_state)  (-> *target* state name))
  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    )
  (none)
  )


(defun target-sync-state ((tgt-state symbol) (t target))
  (case tgt-state
    ;; normal attacks (and relevant jumps) !DONE!
    (('target-running-attack) (go-process t target-running-attack))
    (('target-attack) (go-process t target-attack))
    (('target-attack-air) (go-process t target-attack-air #f))
    (('target-attack-uppercut) (go-process t target-attack-uppercut (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-attack-uppercut-jump) (go-process t target-attack-uppercut-jump (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-flop) (go-process t target-flop (the-as float 33775.48) (the-as float -122880.0)  (the-as float 0.0))) ;;ground pound
    (('target-flop-hit-ground) (go-process t target-flop-hit-ground #f))
    (('target-wheel) (go-process t target-wheel))
    (('target-wheel-flip) (go-process t target-wheel-flip (-> *TARGET-bank* wheel-flip-height) (-> *TARGET-bank* wheel-flip-dist)))
    
    ;; jumps !DONE!
    (('target-jump) (go-process t target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f)))
    (('target-double-jump) (go-process t target-double-jump (-> *TARGET-bank* double-jump-height-min) (-> *TARGET-bank* double-jump-height-max)))
    (('target-high-jump) (go-process t target-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'flip))
    (('target-duck-high-jump) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))
    (('target-duck-high-jump-jump) (go-process t target-duck-high-jump-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))

    ;; eco !DONE!
    (('target-eco-powerup) (send-event t 'powerup))
    (('target-yellow-blast) (go-process t target-yellow-blast))
    (('target-yellow-jump-blast) (go-process t target-yellow-jump-blast))
    (('target-launch) (go-process t target-launch (the-as float (-> t control unknown-dword60)) (the-as symbol (-> t control unknown-dword61)) (-> t control unknown-vector102) (-> t control unknown-dword63)))

    ;; edge grabs !DONE!
    (('target-edge-grab) (go-process t target-edge-grab))
    (('target-edge-grab-off) (go-process t target-edge-grab-off))
    (('target-edge-grab-jump) (go-process t target-edge-grab-jump (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))
    (('target-jump-forward) (go-process t target-jump-forward (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))

    ;; normal movement
    (('target-stance) (go-process t target-stance))
    (('target-stance-ambient) (go-process t target-stance-ambient))
    (('target-walk) (go-process t target-walk))
    (('target-wade-stance) (go-process t target-wade-stance))
    (('target-wade-walk) (go-process t target-wade-walk))
    (('target-ice-stance) (go-process t target-ice-stance))
    (('target-ice-walk) (go-process t target-ice-walk))
    (('target-load-wait) (go-process t target-load-wait)) ;; trip
    (('target-slide-down) (go-process t target-slide-down)) ;; slippery surface
    (('target-turn-around) (go-process t target-turn-around))
    (('target-falling) (go-process t target-falling #f))

    ;; hit !DONE!
    (('target-hit) (go-process t target-hit 'shove (-> t attack-info-rec)))
    (('target-hit-ground) (go-process t target-hit-ground #f))
    (('target-hit-ground-hard) (go-process t target-hit-ground-hard 0.0)) ;;toggle to 1.0 to flash invuln frames)

    ;; tube slide
    (('target-tube-start) (send-event t 'change-mode 'tube #f))
    (('target-tube) (go-process t target-tube))
    (('target-tube-jump) (go-process t target-tube-jump (-> *TARGET-bank* tube-jump-height-min) (-> *TARGET-bank* tube-jump-height-max)))
    ;;(('target-tube-hit) (go-process t target-hit-ground #f)

    ;; poles !TODO: crashes if *target* is in another level so the remote level isn't loaded
    ;; (('target-pole-cycle) (go-process t target-pole-flip-up 28672.0 28672.0 6000.0))
    ;; (('target-pole-flip-forward) (go-process t target-pole-flip-forward (the-as float 14336.0) (the-as float 14336.0) (the-as float 57344.0)))
    ;; (('target-pole-flip-forward-jump) (go-process t target-pole-flip-forward-jump (the-as float 14336.0) (the-as float 14336.0)))
    ;; (('target-pole-flip-up) (go-process t target-pole-flip-up 28672.0 28672.0 6000.0))
    ;; (('target-pole-flip-up-jump) (go-process t target-pole-flip-up-jump 28672.0 28672.0))

    ;; swiming & water
    (('target-swim-stance) (send-event t 'change-mode 'swim) (go-process t target-swim-stance))
    (('target-swim-walk) (send-event t 'change-mode 'swim) (go-process t target-swim-walk))
    (('target-swim-down) (go-process t target-swim-down))
    (('target-swim-up) (go-process t target-swim-up))
    (('target-swim-jump) (go-process t target-swim-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max)))
    (('target-swim-jump-jump) (go-process t target-swim-jump-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max) (the-as surface #f)))
   
    ;; duck !DONE!
    (('target-duck-stance) (go-process t target-duck-stance))
    (('target-duck-walk) (go-process t target-duck-walk))

    ;; warp gates !DONE!
    (('target-warp-out) (if (and (-> t state name) (!= (-> t state name) 'target-duck-high-jump) (!= (-> t state name) 'target-duck-high-jump-jump))(go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck)))
    (('target-warp-in) (if (and (-> t state name) (!= (-> t state name) 'target-duck-high-jump) (!= (-> t state name) 'target-duck-high-jump-jump))(go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck)))


    ;; other
    (('target-clone-anim) (if (and (-> t state name) (!= (-> t state name) 'target-stance)) (run-target-fuel-cell-pickup t)))
    (('target-fishing) (send-event t 'change-mode 'fishing #f))
    (('target-periscope) (send-event t 'change-mode 'periscope #f))
    (('target-grab) (go-process t target-grab)) ;; process-grab animation while in cutscenes

    ;; redundant for multiplayer
    ;; (('target-death) (go-process t target-hit-ground-hard 0.0))
    ;; (('target-look-around) (go-process t target-look-around)) ;; first person enter
    ;; (('target-stance-look-around) (go-process t target-stance-look-around)) ;; first person exit
    ;; (('target-tube-death))
    ;; (('target-billy-game)) ;; will only put you in first person
    ;; (('target-play-anim))
    ;; (('target-snowball))
    ;; (('target-snowball-start))
    ;; (('target-title))
    ;; (('target-title-play))
    ;; (('target-title-wait))
    ;; (('target-continue))
    ;; (('target-demo))
    ;; (('target-startup))
    ;; (('target-final-door))


    ;; zoomer !DONE!
    (('target-racing 'target-racing-start 'target-racing-get-on 'target-racing-bounce 'target-racing-clone-anim 
      'target-racing-falling 'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack)
      
      (if (not (target-on-racer? t))
        (send-event t 'change-mode 'racing #f)
        )
      
      (when (target-on-racer? t) 
        (case tgt-state
          (('target-racing) (go-process t target-racing))
          (('target-racing-bounce) (go-process t target-racing-bounce 2048.0 2048.0 #f))
          (('target-racing-jump) (go-process t target-racing-jump 2048.0 5324.8 #t))
          (('target-racing-smack) (go-process t target-racing-smack (-> t control unknown-float01) #t))
          (('target-racing-grab) (go-process t target-racing-grab))
          (('target-racing-falling) (go-process t target-racing-falling))
          ;; (('target-racing-hit))
          ;; (('target-racing-clone-anim))
          )
        )
      )
    (('target-racing-get-off 'target-racing-get-off-hit-ground 'target-racing-get-off-jump 'target-racing-death)
      (if (target-on-racer? t)
          (send-event t 'end-mode)
        )
      )


    ;; flut flut !DONE!
    (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
      'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
      'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
      
      (if (not (target-on-flut? t))
        (send-event t 'change-mode 'flut #f)
        )

      (when (target-on-flut? t) 
        (case tgt-state
          (('target-flut-stance) (go-process t target-flut-stance))
          (('target-flut-walk) (go-process t target-flut-walk))
          (('target-flut-falling) (go-process t target-flut-falling #f))
          (('target-flut-running-attack) (go-process t target-flut-running-attack))
          (('target-flut-jump) (go-process t target-flut-jump (-> *FLUT-bank* jump-height-min) (-> *FLUT-bank* jump-height-max)))
          (('target-flut-double-jump) (go-process t target-flut-double-jump (-> *FLUT-bank* double-jump-height-min) (-> *FLUT-bank* double-jump-height-max)))
          (('target-flut-air-attack) (go-process t target-flut-air-attack (-> *FLUT-bank* air-attack-speed)))
          (('target-flut-air-attack-hit-ground) (go-process t target-flut-air-attack-hit-ground))
          (('target-flut-grab) (go-process t target-flut-grab))
          (('target-flut-hit) (go-process t target-flut-hit 'shove (-> t attack-info-rec)))
          (('target-flut-hit-ground) (go-process t target-flut-hit-ground ))
          ;; (('target-flut-clone-anim))
          )
      )
      )
    (('target-flut-get-off 'target-flut-get-off-hit-ground 'target-flut-get-off-jump 'target-flut-death)
      (if (target-on-flut? t)
          (send-event t 'end-mode)
        )
      )

    )
  (none)
  )

(defun update-actor-position ((obj process-drawable) (p remote-player-info))
  ;; position
  (set! (-> obj root trans x) (-> p trans_x))
  (set! (-> obj root trans y) (-> p trans_y))
  (set! (-> obj root trans z) (-> p trans_z))
  ;; rotation
  (set! (-> obj root quat x)  (-> p quat_x))
  (set! (-> obj root quat y)  (-> p quat_y))
  (set! (-> obj root quat z)  (-> p quat_z))
  (set! (-> obj root quat w)  (-> p quat_w))

  (color-target obj (-> p color))

  ;; additional steps for rotation, state, etc
  (case (-> obj type)
    ((target)
      (let* ((t (the target obj)))

        ;; zoomer rotation
        (if (target-on-racer? t)
          (set! (-> t racer rot y) (-> p zoomer_rot_y))
          )

        ;; draw usernames for all players
        (add-debug-text-3d
                      #t
                      (bucket-id subtitle)
                      (-> p username)
                      (-> t root trans)
                      (font-color white)
                      (new 'static 'vector2h :y 16)
                      )

        ;; activate invuln for interactive and nuka glitch for ghost targets
        (if (= (-> p mp_state) (mp-tgt-state mp-tgt-interactive))
          (logior! (-> t state-flags) (state-flags invulnerable))
          (logior! (-> t state-flags) (state-flags dying))
        )

        ;; finalize rotation
        (quaternion-copy! (-> t control dir-targ) (-> t root quat))
          
        ;; sync target state
        (when (and (-> t state name) (!= (-> t state name) (-> p tgt_state)) 
        (or (!= (-> p tgt_state) 'target-clone-anim) (= (-> p inter_type) (interaction-type game-task))) ;; only allow fuel cells from 'target-clone-anim
        )
          (target-sync-state (-> p tgt_state) t)
          )
        )
      )
    ((money)
      (let ((m (the money obj)))
        (vector-copy! (-> m base) (-> m root trans))
        (vector-copy! (-> m root-override root-prim world-sphere) (-> m root trans))
        )
      )
    )
    (none)
  )

(defun start-extra-target ()
  (ppointer->handle (process-spawn
                target
                :init init-target
                  (-> *game-info* current-continue)
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                ))
  )

(defun render-targets ()
 (let ((target-count 0))
    (dotimes (idx MAX_MULTIPLAYER_COUNT)
      (when (!= (-> *multiplayer-info* player_num) idx)
        (when (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
          ;; see if we need to spawn any remote targets
          (when (or (zero? (-> *remote-targets* idx)) (not (handle->process (-> *remote-targets* idx))))
            (set! (-> *remote-targets* idx) (start-extra-target))
            (set! (-> (the-as target (handle->process (-> *remote-targets* idx))) saved-owner) idx) ;; used to identify remote index from target
            )
          ;; assume target spawned at this point 

          ;; position/color remote targets
          (let ((p (-> *multiplayer-info* players idx))
                (obj (the process-drawable (handle->process (-> *remote-targets* idx)))))
            (when obj
              (update-actor-position obj p)
              )
            )
            (set! target-count (+ target-count 1))
          )
        )
      )
    ;; despawn newly disconnected targets
    (when (!= target-count *remote-target-active-count*)
      (dotimes (idx MAX_MULTIPLAYER_COUNT)
        (when (!= (-> *multiplayer-info* player_num) idx)
          (when (= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
            (safe-deactivate-remote-target idx)
            )
          )
        )
      (set! *remote-target-active-count* target-count)
      )
    )
  )


(defun get-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


(defun get-interactive-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-interactive)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


;; Macros can be used more-or-less just like functions
(defmacro current-cell-count ()
  `(-> *game-info* fuel)
  )

(defmacro set-current-cell-count (count)
  `(set! (-> *game-info* fuel) ,count)
  )
  
(defun increase-power-cell-by-one ()
  (set-current-cell-count (+ (current-cell-count) 1))
  ;; with the two macros defined above, this is equivalent to
  ;; (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Approved Custom Functions/Macros to call in all mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; These are included with the mod base and you are welcome to use them in your mods!

(defmacro current-checkpoint-name ()
  `(-> *game-info* current-continue name)
  )

(defun set-current-checkpoint-by-name ((name string))
  (set-continue! *game-info* name)
  )

(defmacro current-level-name ()
  `(-> (level-get-target-inside *level*) name)
  )
  
(defmacro current-orb-count ()
  `(-> *game-info* money)
  )

(defmacro current-cutscene ()
  `(-> *art-control* active-stream)
  )

;;This function moves an actor to the given coordinates
;;example: (move-actor "farmer-3" 3.0 74.0 -120.0)
(defun move-actor ((actor-name string) (x float) (y float) (z float))
  (when (entity-by-name actor-name)
    (let* ((entity-actor (entity-by-name actor-name))
           (actor (-> entity-actor extra process))
           )
      (when actor
        (case (-> actor type)
          ((fuel-cell)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
            (when (name= (-> (the fuel-cell actor) state name) 'wait)
              ;; only move collision when idle (messes up glowing in cutscene)
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((orb-cache-top)
            ;; don't move while its activated (let it go up/down)
            (when (not (name= (-> (the orb-cache-top actor) state name) 'orb-cache-top-activate))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) basetrans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere z) (meters z))
              (set-vector! (-> (the orb-cache-top actor) draw origin) (meters x) (meters y) (meters z) 1.0)
              (let ((radius (-> (the process-drawable actor) draw radius))
                    (bounds (res-lump-data entity-actor 'visvol (inline-array vector)))
                    )
                (set-vector! (-> bounds 0) (- (meters x) radius) (meters y) (- (meters z) radius) 1.0)
                (set-vector! (-> bounds 1) (+ (meters x) radius) (meters y) (+ (meters z) radius) 1.0)
                )
              )
            )
          ((money)
            ;; don't move orbs if being blue-eco-sucked
            (when (not (logtest? (-> (the money actor) flags) (collectable-flags suck)))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the money actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the money actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the money actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((crate crate-buzzer)
            ;; only move crates if they're not jumping
            (when (= (-> (the crate actor) smush amp) 0.0)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the crate actor) base) (meters x) (meters y) (meters z) 1.0)
              ;; (set-vector! (-> (the crate actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere x) (meters x))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere y) (meters y))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((darkvine)
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
          )
          (else
            (format 0 "unexpected actor type ~S ~S ~S~%" actor-name (-> entity-actor type) (-> actor type))
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
            )
          )
        )
      )
    )
  (none)
  )

(defun spawn-actor-by-name ((name string))
  ;; Takes in the string of name of a actor, and spawns a new process based on the entity.
    (let* ((entity-actor (the entity-actor (entity-by-name name)))
          (type (-> entity-actor etype))
          (e-info (entity-info-lookup type))
      )
      (when (entity-by-name name)
        (init-entity 
          (get-process *default-dead-pool* type (if e-info (-> e-info heap-size) #x4000)) 
          entity-actor)
          (sound-play "buzzer-pickup")
      )
      (if (not (entity-by-name name))
          (sound-play "oof")
      )
    )
    (none)
)

;;Draws a debug sphere on the actor, takes in a string actor name and a radius for the sphere in meters
(defun draw-debug-sphere-on-actor ((actorName string)(radius float))
  (when *debug-segment*
    (when (process-by-ename actorName)
      (add-debug-sphere #t (bucket-id debug)  (-> (the-as process-drawable (process-by-ename actorName)) root trans) (meters radius) (static-rgba 0 #xff 0 #x40))
    )
  )
  (none)
)


;;This function moves a given actor to jaks current position, then prints a (move-actors) call in gk.exe
(defun move-to-jak ((arg0 string))
(format #t "move-actor code:  (move-actor ~a ~m ~m ~m)~%" arg0(-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z))
  (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) crate)
    (begin
        (set! (-> (the crate (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )
  )
)

;; quick macro for setting vector xyz in meters, leaving w alone
(defmacro set-vector-meters! (dst x y z)
  `(set-vector! ,dst (meters ,x) (meters ,y) (meters ,z) (-> ,dst w))
  )

;; quick macro for constructing static vector with w=1
(defmacro static-vector-meters (x y z)
  `(new 'static 'vector :x (meters ,x) :y (meters ,y) :z (meters ,z) :w 1.0)
  )

;; prints vector xyz in meters
(defmacro print-vector-meters (vec &key (dst #t))
  `(format ,dst "~m ~m ~m~%" (-> ,vec x) (-> ,vec y) (-> ,vec z))
  )

;; takes a path-control and xyz values to offsets every node in the path by
(defmacro shift-path! (path x y z)
  `(let ((voff (static-vector-meters ,x ,y ,z)))
    (dotimes (idx (-> ,path num-cverts))
      (vector+! (-> ,path cverts idx) (-> ,path cverts idx) voff)
      )
    )
  )

;; prints all the nodes in a path in meters
(defmacro path-print-meters (path)
  `(dotimes (idx (-> ,path num-cverts))
    (print-vector-meters (-> ,path cverts idx))
    )
  )

;; prints the position (root trans) of a process-drawable
(defmacro pd-pos-m (procname)
  `(let* ((obj (the process-drawable (process-by-ename ,procname)))
          (vec (-> obj root trans)))
    (format 0 "~m ~m ~m~%" (-> vec x) (-> vec y) (-> vec z) 4096.0)
    (none)
    )
  )

;;This function moves an actor based on jaks position + an offset
(defun move-to-behind-jak ((arg0 string) (arg1 meters) (arg2 meters))
 (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-(-> (target-pos 0) x) (meters arg1)) (+ (-> (target-pos 0) y) (meters arg2)) (-(-> (target-pos 0) z)(meters arg1)) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
    (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
  )
)

;;This turns on play hints
(defun turnonplayhints ()
(set! (-> *setting-control* default play-hints) #t)
)

;;This turns off playhints
(defun turnoffplayhints()
(set! (-> *setting-control* default play-hints) #f)
)

;;This turns on collision render when called
(defun turnonCollisionmode()
  (set! *collision-renderer* #t)
  (logclear! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This turns off collision render when called
(defun turnoffCollisionmode()
  (set! *collision-renderer* #f)
  (logior! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This makes it thunder in the current level
(defun thunderTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village2)
  (set! (-> (level-get-target-inside *level*) mood) *village2-mood*)
)

;;This makes the current level dark when called
(defun DarkesetGlitchTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-finalboss )
  (set! (-> (level-get-target-inside *level*) mood) *finalboss-mood*)
)

;;This needs fixed
(defun rainyTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-swamp)
  (set! (-> (level-get-target-inside *level*) mood) *swamp-mood*)
)

;;This needs fixed
(defun snowingTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-snow)
  (set! (-> (level-get-target-inside *level*) mood) *snow-mood*)
)

;;This makes the current levels weather the same as village1
(defun defaultWeatherTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village1)
  (set! (-> (level-get-target-inside *level*) mood) *village1-mood*)
)

;;This moves jak to a provided coordinate example call
;;(tp-jak 0.0 12.0 32.32)
(defun tp-jak ((arg0 float)(arg1 float)(arg2 float))
  (set! (-> (target-pos 0) x) (meters arg0))
  (set! (-> (target-pos 0) y) (meters arg1))
  (set! (-> (target-pos 0) z) (meters arg2))
)

;;This returns true or false depending on if jak is within a provided distance from an actor
(defun close? ((actor-ename string) (dist float))
  (and 
    (process-by-ename actor-ename)
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> (the process-drawable (process-by-ename actor-ename)) root trans)
        )
      dist
      )
    )
  )
(defun process-close? ((proc process-drawable) (dist float))
  (and 
    proc
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> proc root trans)
        )
      dist
      )
    )
  )

(defun remote-target-process-close? ((remote-target target) (proc process-drawable) (dist float))
  (and 
    proc
    (<= 
      (vector-vector-distance 
        (remote-target-pos 0 remote-target) 
        (-> proc root trans)
        )
      dist
      )
    )
  )

;;This returns true or false depending on if all jaks are within a provided distance from an actor
(defun any-interactive-targets-close? ((proc process-drawable) (dist float))
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((target (get-interactive-target tgt-idx)))
      (if (and target (and proc (<= (vector-vector-distance (remote-target-pos 0 target) (-> proc root trans)) dist)))
          (return #t)
        )
      )
    )
    #f
  )


;;This returns true or false if jak is within a bubble defined by coordiantes and width
(defun in-bubble? ((x float) (y float) (z float) (w float))
  (<= 
    (vector-vector-distance 
      (target-pos 0) 
      (set-vector! (new-stack-vector0) x y z 1.0)
      )
    (/ w 2.0)
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Jak Color functions
;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun draw-xyz ((jak target) (x float) (y float) (z float))
  (set! (-> jak draw color-mult x) x)
  (set! (-> jak draw color-mult y) y)
  (set! (-> jak draw color-mult z) z)
)
(defun draw-normal ((jak target))
  (draw-xyz jak 1.0 1.0 1.0)
)
(defun draw-white ((jak target))
  (draw-xyz jak 3.5 3.5 3.5)
)
(defun draw-black ((jak target))
  (draw-xyz jak 0.1 0.1 0.1)
)
(defun draw-red ((jak target))
  (draw-xyz jak 0.8 0.2 0.2)
)
(defun draw-green ((jak target))
  (draw-xyz jak 0.0 1.2 0.0)
)
(defun draw-blue ((jak target))
  (draw-xyz jak 0.0 0.5 2.0)
)
(defun draw-yellow ((jak target))
  (draw-xyz jak 1.5 1.5 0.0)
)
(defun draw-pink ((jak target))
  (draw-xyz jak 1.0 0.0 1.0)
)
(defun draw-light-blue ((jak target))
  (draw-xyz jak 0.0 1.0 1.0)
)



