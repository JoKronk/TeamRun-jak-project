    ;;-*-Lisp-*-
    (in-package goal)

    ;; name: mod-custom-code.gc
    ;; name in dgo: mod-custom-code
    ;; dgos: TODO


    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; What is this file for.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;

    #| This file contains function defenitions that are pre placed in the mod base,
    so if you place custom code inside of these functions, it will exectue based on
    the name of the function, for example, if you place (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
    to the function named runs-on-orb-pickup, then jaks powercell count will increase each time you collect
    an orb |#


    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Begin function defintions.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    (defun update-state ()
      (if (and (= *cheat-mode* #f) (= *debug-segment* #f))
        (set! (-> *teamrun-info* debug_mode_active?) 0)
        (set! (-> *teamrun-info* debug_mode_active?) 1)
        )

      (set! (-> *teamrun-info* cell_count) (the int32 (-> *game-info* fuel)))
      (set! (-> *teamrun-info* buzzer_count) (the int32 (-> *game-info* buzzer-total)))
      (set! (-> *teamrun-info* money_count) (the int32 (-> *game-info* money)))
      (set! (-> *teamrun-info* death_count) (the int32 (-> *game-info* total-deaths)))

      (set! (-> *teamrun-info* has_state_update?) 1)
      (set! *has-none-position-update?* #t)
    (none)
    )

    (defun check-allow-cell-pickup? ()
      *allow-cell-pickup?*
    )

    (defun check-allow-final-boss? ()
      *allow-final-boss?*
    )

    (defun runs-on-level-enter ()
      (when (and (!= *target* #f) (!= (-> (level-get-target-inside *level*) name) 'title))
        (set! (-> *teamrun-info* current_level) (symbol->string (-> (level-get-target-inside *level*) name)))
        (if (!= (-> *game-info* current-continue level) (-> *teamrun-info* current_level))
          (update-state)
          )
        )
    (none)
    )

    (defun runs-after-save-load ()
        (update-state)
    )


    (defun set-zoomer-wait-mode ()
      (set! (-> *racer-mods* target-speed) 33840.0)
      (set! (-> *racer-air-mods* target-speed) 33840.0)
    )
    (defun set-zoomer-full-mode ()
      (set! (-> *racer-mods* target-speed) 163840.0)
      (set! (-> *racer-air-mods* target-speed) 163840.0)
    )

    (defun runs-on-zoomer-entry ()
      (set! (-> *teamrun-info* on_zoomer?) 1)
        (update-state)
    (none)
    )

    (defun runs-on-zoomer-exit ()
      (set! (-> *teamrun-info* on_zoomer?) 0)
        (update-state)
    )

    (defun runs-on-debug-toggle ()
      (update-state)
    )

    (defun runs-on-warp-gate-open ((task game-task))
      (none)
    )

    (defun runs-on-new-checkpoint ()
      (when (and (!= *target* #f) (!= (-> (level-get-target-inside *level*) name) 'title))
        (set! (-> *teamrun-info* current_checkpoint) (-> *game-info* current-continue name))
        (update-state)
      )
      (none)
    ) 

    (defun runs-on-level-status-update ()
      ;; this could/should be improved to some more dynamic structure
      ;; especially if we want to support multiplayer in jak 2 in the future as well

      (when (and (!= *target* #f) (!= (-> (level-get-target-inside *level*) name) 'title))
        (when (-> *level* level 0)
          (set! (-> *teamrun-levels-info* level0_name) (symbol->string (-> *level* level 0 name)))
          (set! (-> *teamrun-levels-info* level0_status) (symbol->string (-> *level* level 0 status)))
          )

        (when (-> *level* level 1)
          (set! (-> *teamrun-levels-info* level1_name) (symbol->string (-> *level* level 1 name)))
          (set! (-> *teamrun-levels-info* level1_status) (symbol->string (-> *level* level 1 status)))
          )

        
        (set! (-> *teamrun-levels-info* has_level_update?) 1)
        (set! *has-none-position-update?* #t)
        )
      (none)
      )

    (defun reset-specific-actor ((actor-name string))
      (let* ((actor-obj (process-by-ename actor-name)))
        (when (-> actor-obj entity)
          (kill! (-> actor-obj entity))
          (update-perm! (-> actor-obj entity extra perm) 'life (the-as entity-perm-status 623))
          )
        )
        (none)
      )

    (defun safe-break-crate ((crate-name string))
    (let* ((obj-crate (process-by-ename crate-name)))
      (if (not (or (name= (-> (the-as crate obj-crate) state name) "die") (name= (-> (the-as crate obj-crate) state name) "special-contents-die")))
        (go-virtual-process (the-as crate obj-crate) die #f 0)
        )
      )
      (none)
      )

    (defun safe-kill-cache-orb ((cache-name string))
      (let* ((orb-cache (process-by-ename cache-name)))
        (when (-> orb-cache state)
          (case (-> orb-cache state)
            ((orb-cache-top-activate)
                (deactivate (handle->process (-> (the-as orb-cache-top orb-cache) money-list (- (-> (the-as orb-cache-top orb-cache) money) 1))))
              )
            ((orb-cache-top-idle)
              (set! (-> (the-as orb-cache-top orb-cache) money) (- (-> (the-as orb-cache-top orb-cache) money) 1))
              (set! (-> (the-as orb-cache-top orb-cache) entity extra perm user-int16 0) (- 15 (-> (the-as orb-cache-top orb-cache) money)))
              )
            )
          )
        )
        (none)
      )

    (defun safe-kill-crate-orb ((crate-name string))
      (let* ((obj-crate (process-by-ename crate-name)))

        (when (name= (-> (the-as crate obj-crate) state name) "wait")
          (set! (-> (the-as crate obj-crate) fact pickup-amount) (- (-> (the-as crate obj-crate) fact pickup-amount) 1))
          (when (<= (-> (the-as crate obj-crate) fact pickup-amount) 0)
            (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status bit-4) #f)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)
            (process-entity-status! (the-as crate obj-crate) (entity-perm-status complete) #t)
            ((method-of-type crate deactivate) (the-as crate obj-crate))
            )
          (return #t)
          )

        (when (name= (-> (the-as crate obj-crate) state name) "special-contents-die") ;; when in orb collect phase

          (when (>= (-> (the-as crate obj-crate) entity extra perm user-int8 0) 1) ;; all orbs have not been collected

            (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) (+ (-> (the-as crate obj-crate) entity extra perm user-int8 1) 1))
            (+! (-> (the-as crate obj-crate) child-count) -1)

            ;; depspawn orb if exists
            (if (-> (the-as crate obj-crate) child 0)
              ((method-of-type money deactivate) (the-as money (-> (the-as crate obj-crate) child 0)))
              )

            ;; mark as completed if done
            (when (or (= (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0) (= (-> (the-as crate obj-crate) entity extra perm user-int8 1) (float->int (-> (the-as crate obj-crate) fact pickup-amount)))) ;; if no orbs are left
                (set! (-> (the-as crate obj-crate) entity extra perm user-int8 1) 0)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status bit-4) #f)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)
                (process-entity-status! (the-as crate obj-crate) (entity-perm-status complete) #t)
                ((method-of-type crate deactivate) (the-as crate obj-crate))
              )
            )
          )
        )
        (none)
      )

    (defun safe-kill-crate-buzzer ((crate-name string))
      (let* ((obj-crate (process-by-ename crate-name)))

        (process-entity-status! (the-as crate obj-crate) (entity-perm-status dead) #t)
        (process-entity-status! (the-as crate obj-crate) (entity-perm-status complete) #t)

        ;; depspawn buzzer if exists
        (if (and (name= (-> (the-as crate obj-crate) state name) "special-contents-die") (-> (the-as crate obj-crate) child 0))
          ((method-of-type buzzer deactivate) (the-as buzzer (-> (the-as crate obj-crate) child 0)))
          )
        ;; depspawn crate
        ((method-of-type crate deactivate) (the-as crate obj-crate))
        )
        (none)
      )

    (defun safe-pickup-crate-eco ((crate-name string))
      (let* ((obj-crate (process-by-ename crate-name)))

        (if (name= (-> (the-as crate obj-crate) state name) "wait")
          (safe-break-crate crate-name)
          )

        ;; pickup eco if exists
        (when (and (name= (-> (the-as crate obj-crate) state name) "special-contents-die") (-> (the-as crate obj-crate) child 0))
          (go-virtual-process (the-as eco-collectable (-> (the-as crate obj-crate) child 0)) pickup #f (the-as handle #f))
          )
        )
        (none)
      )

    (defun safe-pickup-eco ((eco-ename string))
      (let* ((obj-eco (process-by-ename eco-ename)))
        (when (-> obj-eco name)
          (go-virtual-process (the-as eco-collectable obj-eco) pickup #f (process->handle (the-as eco-collectable obj-eco)))
          )
        )
        (none)
      )

    (defun safe-release-from-grab ()
      (when (is-grabbed?)
        (process-release? *target*)
        )
      )

    (defun add-task-to-buffer ((arg0 game-task) (arg1 task-status))
      (dotimes (idx (-> *task-update-buffer* length))
        (when (= (-> *task-update-buffer* idx status) (task-status invalid))
          (set! (-> *task-update-buffer* idx task) arg0)
          (set! (-> *task-update-buffer* idx status) arg1)
          (return #t)
          )
        )
      (none)
      )

    (defun add-money-to-buffer ((parent-ename string) (money-ename string) (level-name string))
      (dotimes (idx (-> *money-update-buffer* length))
        (when (= (-> *money-update-buffer* idx has_update?) #f)
          (set! (-> *money-update-buffer* idx parent_ename) parent-ename)
          (set! (-> *money-update-buffer* idx ename) money-ename)
          (set! (-> *money-update-buffer* idx level_name) level-name)
          (set! (-> *money-update-buffer* idx has_update?) #t)
          (return #t)
          )
        )
      (none)
      )


    (defun add-crate-to-buffer ((crate-ename string) (crate-type string) (crate-amount int) (level-name string))
      (dotimes (idx (-> *crate-update-buffer* length))
        (when (= (-> *crate-update-buffer* idx has_update?) #f)
          (set! (-> *crate-update-buffer* idx ename) crate-ename)
          (set! (-> *crate-update-buffer* idx type) crate-type)
          (set! (-> *crate-update-buffer* idx amount) crate-amount)
          (set! (-> *crate-update-buffer* idx level_name) level-name)
          (set! (-> *crate-update-buffer* idx has_update?) #t)
          (return #t)
          )
        )
      (none)
      )

    (defun check-set-teamrun-task-from-buffer ()
      (dotimes (idx (-> *task-update-buffer* length))
        (when (!= (-> *task-update-buffer* idx status) (task-status invalid))

          (when (string= (enum->string game-task (-> *task-update-buffer* idx status)) "*unknown*")
            (set! (-> *task-update-buffer* idx status) (task-status invalid))
            (return #t)
            )

          (set! (-> *teamrun-info* task_name) (enum->string game-task (-> *task-update-buffer* idx task)))
          (set! (-> *teamrun-info* task_status) (enum->string task-status (-> *task-update-buffer* idx status)))
          (set! (-> *teamrun-info* has_task_update?) 1)
          (update-state)

          (set! (-> *task-update-buffer* idx status) (task-status invalid))
          (return #t)
          )
        )
    )

    (defun check-set-teamrun-money-collected-from-buffer ()
      (dotimes (idx (-> *money-update-buffer* length))
        (when (= (-> *money-update-buffer* idx has_update?) #t)

          (set! (-> *teamrun-info* money_ename) (-> *money-update-buffer* idx ename))
          (set! (-> *teamrun-info* money_parent_ename) (-> *money-update-buffer* idx parent_ename))
          (set! (-> *teamrun-info* collectable_level_name) (-> *money-update-buffer* idx level_name))
          (set! (-> *teamrun-info* has_money_update?) 1)
          (set! *has-none-position-update?* #t)

          (set! (-> *money-update-buffer* idx has_update?) #f)
          (return #t)
          )
        )
    )

    (defun check-set-teamrun-crate-destroyed-from-buffer ()
      (dotimes (idx (-> *crate-update-buffer* length))
        (when (= (-> *crate-update-buffer* idx has_update?) #t)

          (set! (-> *teamrun-info* crate_ename) (-> *crate-update-buffer* idx ename))
          (set! (-> *teamrun-info* crate_type) (-> *crate-update-buffer* idx type))
          (set! (-> *teamrun-info* crate_amount) (-> *crate-update-buffer* idx amount))
          (set! (-> *teamrun-info* collectable_level_name) (-> *crate-update-buffer* idx level_name))
          (set! (-> *teamrun-info* has_crate_update?) 1)
          (set! *has-none-position-update?* #t)

          (set! (-> *crate-update-buffer* idx has_update?) #f)
          (return #t)
          )
        )
    )


    (defun manual-position-update ((num int) (transX float) (transY float) (transZ float) (quatY float) (quatZ float) (quatW float) (state string))
      (set! (-> *multiplayer-info* players num trans_x)    transX)
      (set! (-> *multiplayer-info* players num trans_y)    transY)
      (set! (-> *multiplayer-info* players num trans_z)    transZ)
      (set! (-> *multiplayer-info* players num quat_y)     quatY)
      (set! (-> *multiplayer-info* players num quat_z)     quatZ)
      (set! (-> *multiplayer-info* players num quat_w)     quatW)
      (set! (-> *multiplayer-info* players num tgt_state)  (string->symbol state))
      (none)
      )


    (defun runs-every-frame ()
      (when (and (!= *target* #f) (!= (-> (level-get-target-inside *level*) name) 'title))
      
      ;; setup our own remote-player-info if we haven't yet
      (set-up-self-remote-if-null)

      (when (and *target* (>= (-> *multiplayer-info* player_num) 0) (!= (-> *self-player-info* mp_state) (mp-tgt-state mp-tgt-disconnected)))

        (check-set-teamrun-task-from-buffer)
        (check-set-teamrun-money-collected-from-buffer)
        (check-set-teamrun-crate-destroyed-from-buffer)

        ;; on player movement
        (when (or (!= (-> *self-player-info* trans_x) (-> *target* root trans x))
        (!= (-> *self-player-info* trans_y) (-> *target* root trans y))
        (!= (-> *self-player-info* trans_z) (-> *target* root trans z))
        (!= (-> *self-player-info* tgt_state) (-> *target* state name))
        (= *has-none-position-update?* #t))
            ;; update this player's position
            (update-self-multiplayer-info)
            ;; (update-debug-self-multiplayer-info)
            
            ;; send updated player info to client
            (pc-update-position)


            ;; clean none position updates
            (when (= *has-none-position-update?* #t)
              (set! *has-none-position-update?* #f)
              
              (set! (-> *teamrun-info* has_state_update?) 0)
              (set! (-> *teamrun-info* just_spawned?) 0)
              
              (set! (-> *teamrun-info* has_task_update?) 0)
              (set! (-> *teamrun-info* has_buzzer_update?) 0)
              (set! (-> *teamrun-info* has_money_update?) 0)
              (set! (-> *teamrun-info* has_crate_update?) 0)
              (set! (-> *teamrun-info* has_eco_update?) 0)

              (set! (-> *teamrun-levels-info* has_level_update?) 0)
              )


            (if (= (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-disconnected))
              (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) mp_state) (mp-tgt-state mp-tgt-interactive))
              )
          )

        (render-targets)

        
        ;; color ourselves
        (color-target *target* (-> *self-player-info* color))

        )
      )
      (none)
      )

    (defun runs-on-crate-break ((crate-ename string) (crate-type string) (crate-amount int) (level-name string))
      (add-crate-to-buffer crate-ename crate-type crate-amount level-name)

      (none)
      )

    (defun runs-on-orb-pickup ((parent process-tree) (money-ename string) (level-name string))

      (if (name= (-> parent name) "entity-pool")
        (add-money-to-buffer (symbol->string (-> parent name)) money-ename level-name)
        (add-money-to-buffer (the-as string (-> parent name)) money-ename level-name)
        )

      (let* ((from-cache? (and parent (type-type? (-> parent type) orb-cache-top))))
        ;; Code here runs on ANY orb pickup


        (when from-cache?
          ;; Code here runs only if the orb was from an orb cache

          )

        (when (not from-cache?)
          ;; Code here runs only if the orb was NOT from an orb cache

          )
        )
      (none)
      )

    (defun runs-on-fly-pickup ((buzzer-id int32) (parent-ename string) (level-name string))
      ;; Code here runs on any scout fly pickup
      (set! (-> *teamrun-info* buzzer_id) buzzer-id)
      (set! (-> *teamrun-info* buzzer_parent_ename) parent-ename)
      (set! (-> *teamrun-info* collectable_level_name) level-name)
      (set! (-> *teamrun-info* has_buzzer_update?) 1)
      (set! *has-none-position-update?* #t)
      (none)
      )

    (defun runs-on-cell-pickup ((cell-event symbol))
      (case cell-event
        (('pickup)      
          ;; Code here runs as soon as you pickup a powercell
          
          (safe-deactivate-remote-cell)
          )
        (('cutscene-end)      
          ;; Code here runs at the end of any powercell cutscene

          )
        )

      (none)
      )

    (defun runs-on-eco-pickup ((eco-type pickup-type) (parent process-tree) (eco-ename string))
      (let* ((from-vent? (and parent (type-type? (-> parent type) vent))))
        ;; Code here runs as soon as you pickup ANY eco

        (when (not from-vent?)
          (case eco-type
            (((pickup-type eco-yellow) (pickup-type eco-red) (pickup-type eco-blue))

              (if (name= (-> parent name) "entity-pool")
                (set! (-> *teamrun-info* eco_ename) eco-ename)
                (set! (-> *teamrun-info* eco_ename) (symbol->string eco-ename))
                )
              (if (name= (-> parent name) "entity-pool")
                (set! (-> *teamrun-info* eco_parent_ename) (symbol->string (-> parent name)))
                (set! (-> *teamrun-info* eco_parent_ename) (the-as string (-> parent name)))
                )
              (set! (-> *teamrun-info* collectable_level_name) (-> *teamrun-info* current_level))
              (set! (-> *teamrun-info* has_eco_update?) 1)
              (set! *has-none-position-update?* #t)
              )
            )
          )

        (case eco-type
          (((pickup-type eco-yellow))      
            ;; Code here runs as soon as you pickup yellow eco

            )
          (((pickup-type eco-red))      
            ;; Code here runs as soon as you pickup red eco

            )
          (((pickup-type eco-blue))      
            ;; Code here runs as soon as you pickup blue eco

            )
          (((pickup-type eco-pill))      
            ;; Code here runs as soon as you pickup small green eco

            )
          (((pickup-type eco-green))      
            ;; Code here runs as soon as you pickup big green eco 

            )
          )
        
        (when from-vent?
          ;; Code here runs only if the eco was picked up from a vent

          )
        )

      (none)
      )

    (defun runs-on-jak-spawn ()
      ;; Code here runs every time jak spawns (loading a file new game or death)   
      (set! (-> *teamrun-info* on_zoomer?) 0)
      (set! (-> *teamrun-info* just_spawned?) 1)
      (update-state)

      (when (and (string= (-> *game-info* current-continue name) "finalboss-fight") (= *allow-final-boss?* #f))
        (set-continue! *game-info* "finalboss-start")
        (+! (-> *target* root trans x) (meters -161.0))
        (+! (-> *target* root trans z) (meters 120.0))
        (+! (-> *target* root trans y) (meters 90.0))
        (send-event *camera* 'change-state cam-string 0)
      )
      
      (none)
      )

    (defun runs-on-jak-death ((death-event symbol))
      (case death-event
        (('dying)
          ;; Code here runs immediately every time jak dies, before any death animation or death cutscene
          
          )
        (('blackout)
          ;; Code here runs after jak dies (and any death cutscene finishes), during the blackout before he spawns

          )
        )
      
      (none)
      )


    ;; Custom checkpoint storage
    (define *tmp-continue-point* (new 'static 'continue-point
      :name "tmp"
      :level #f
      :trans (new 'static 'vector :w 1.0)
      :quat (new 'static 'quaternion :w 1.0)
      :camera-trans (new 'static 'vector :w 1.0)
      :camera-rot (new 'static 'array float 9)
      :load-commands '()
      :vis-nick #f
      :lev0 #f
      :disp0 #f
      :lev1 #f
      :disp1 #f
      )
      )
      
    (define *tmp-flut?* #f)
    (define *tmp-zoomer?* #f)
    (define *full-hp?* #f)
    (define *last-real-continue-point* (the-as continue-point #f))
    
    (defun continue-point-copy! ((dst continue-point) (src continue-point))
      (set! (-> dst level) (-> src level))
      (set! (-> dst quat y) 0.0)
      (set! (-> dst quat w) 1.0)
      (set! (-> dst load-commands) (-> src load-commands))
      (set! (-> dst vis-nick) (-> src vis-nick))
      (when (-> *level* level0)
        (set! (-> dst lev0) (-> *level* level0 name))
        (set! (-> dst lev0) (-> *level* level0 name))
        (set! (-> dst disp0) (-> *level* level0 display?))
        )
      (when (-> *level* level1)
        (set! (-> dst lev1) (-> *level* level1 name))
        (set! (-> dst disp1) (-> *level* level1 display?))
        )
      (none)
      )

    
    (defun camera-rot-copy! ((dst continue-point) (src matrix))
      (set! (-> dst camera-rot 0) (-> src vector 0 x))
      (set! (-> dst camera-rot 1) (-> src vector 0 y))
      (set! (-> dst camera-rot 2) (-> src vector 0 z))
      (set! (-> dst camera-rot 3) (-> src vector 1 x))
      (set! (-> dst camera-rot 4) (-> src vector 1 y))
      (set! (-> dst camera-rot 5) (-> src vector 1 z))
      (set! (-> dst camera-rot 6) (-> src vector 2 x))
      (set! (-> dst camera-rot 7) (-> src vector 2 y))
      (set! (-> dst camera-rot 8) (-> src vector 2 z))
      (none)
      )


    (defun speedrun-reset-common-settings ()
      ;; disable hints (this seems to be overriden by your slot 1 save though)
      (set! (-> *setting-control* default play-hints) #f)
      ;; ensure `force actors` is not enabled
      ;; (set! (-> *pc-settings* ps2-actor-vis?) #t)
      ;; force FPS to `60`
      ;; (set-frame-rate! *pc-settings* 60 #t)
      ;; skip intro cutscene
      (close-specific-task! (game-task intro) (task-status need-resolution))
      (none)
      )

    
    (defun spawn-temp-checkpoint ()
      (when (-> *tmp-continue-point* level)
        ;; store last real checkpoint to restore later
        (when (not (string= (-> *game-info* current-continue name) "tmp"))
          (set! *last-real-continue-point* (-> *game-info* current-continue))
          )
        (set! (-> *game-info* current-continue) *tmp-continue-point*)
        (initialize! *game-info* 'dead (the-as game-save #f) (the-as string #f))
        (speedrun-reset-common-settings)
        )
      (none)
      )

    (defun store-temp-checkpoint ()
      ;; outside of bsp breaks shit
      (when (or (-> *level* level0 inside-boxes?) (-> *level* level1 inside-boxes?))
        ;; assume current continue is good enough for the current location
        (continue-point-copy! *tmp-continue-point* (-> *game-info* current-continue))
        (vector-copy! (-> *tmp-continue-point* trans) (-> *target* root trans))
        (quaternion-copy! (-> *tmp-continue-point* quat) (-> *target* control unknown-quaternion00))
        (vector-copy! (-> *tmp-continue-point* camera-trans) (-> *camera-combiner* trans))
        (camera-rot-copy! *tmp-continue-point* (-> *camera-combiner* inv-camera-rot))

        (set! *full-hp?* (and (!= *target* #f)
                      (= (-> *target* fact-info-target health) 3.0)
                      (= (-> *target* fact-info-target eco-pill) 50.0)
                      ))
        (set! *tmp-flut?* #f)
        (set! *tmp-zoomer?* #f)
        (case (-> *target* state)
          ((target-flut-stance)
            (set! *tmp-flut?* #t)
            )
          ((target-racing)
            (set! *tmp-zoomer?* #t)
            )
          )
        )
      (none)
      )


    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; deprecated function defintions.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;

    #| these are no longer recommended/supported however we include them anyways to not break anyones mods.
    |#
