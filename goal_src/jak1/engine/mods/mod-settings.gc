;;-*-Lisp-*-
(in-package goal)

;; name: mod-common-functions.gc
;; name in dgo: mod-common-functions
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file is a place where you can define custom functions and GOAL code
 to call inside of mod-custom-code.gc for example I have defined a function that increases
 the powercell count by one when it is called
 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Useful GOAL modding documentation
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| 
Checks the condition and if it is true it does first argument if false it does optional second argument
(if (condition) (do if true) (do if false))

Gives a random FLOAT or INT between the provided ranges when called
(rand-vu-float-range 0.0 2.0)
(rand-vu-int-range 0 10)

if the result of rand-vu-int-range is 1, then DANCE! if it is not 1, then Don't dance
(if (= (rand-vu-int-range 0 10) 1) (DANCE!) (Don't dance))


|#

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Settings to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

(define startingDebugContinuePoint "village1-hut")

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Settings Variables to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Change #f to #t here to remove flutflut's invisible walls and prevent deload crashes
(define *allow-flutflut-anywhere* #f)

;; Change #f to #t here to remove zoomer's invisible walls and prevent deload crashes
(define *allow-zoomer-anywhere* #f)

;; Change #f to #t here to show the input display by default
(define *show-input-display* #f)



(deftype remote-player-info (structure)
 ((username   string)
  (color      tgt-color)
  (trans_x    float)
  (trans_y    float)
  (trans_z    float)
  (quat_x     float)
  (quat_y     float)
  (quat_z     float)
  (quat_w     float)
  (tgt_state  symbol)
  (mp_state   mp-tgt-state) 
  )
  :pack-me
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defconstant MAX_USERNAME_LEN 100)

(defmethod new remote-player-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj username) (new 'global 'string MAX_USERNAME_LEN (the-as string #f)))
    (set! (-> obj color) (tgt-color green))
    (set! (-> obj trans_x) 0.0)
    (set! (-> obj trans_y) 0.0)
    (set! (-> obj trans_z) 0.0)
    (set! (-> obj quat_x) 0.0)
    (set! (-> obj quat_y) 0.0)
    (set! (-> obj quat_z) 0.0)
    (set! (-> obj quat_w) 0.0)
    (set! (-> obj tgt_state) 'invalid)
    (set! (-> obj mp_state) (mp-tgt-state mp-tgt-disconnected))
    obj
    )
  )


(deftype teamrun-player-info (structure)
 (
  ;; state updates
  (has_state_update?    int32)
  (debug_mode_active?    int32)
  (current_level   string)
  (current_checkpoint      string)
  (on_zoomer?    int32)
  (just_spawned?    int32)
  (cell_count    int32)
  (buzzer_count    int32)
  (money_count    int32)
  (death_count    int32)

  ;; task updates
  (has_task_update?    int32)
  (task_name   string)
  (task_status   string)

  ;; buzzer updates
  (has_buzzer_update?    int32)
  (buzzer_id    int32)
  (buzzer_parent_ename   string)

  ;; money updates
  (has_money_update?    int32)
  (money_ename    string)
  (money_parent_ename   string)

  ;; crate updates
  (has_crate_update?    int32)
  (crate_ename    string)
  (crate_type   string)
  (crate_amount   int32)

  ;; eco updates
  (has_eco_update?    int32)
  (eco_ename    string)
  (eco_parent_ename   string)

  ;; shared update data
  (collectable_level_name   string)
  )
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new teamrun-player-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
  ;; state update
    (set! (-> obj has_state_update?) 0)
    (set! (-> obj debug_mode_active?) 0)
    (set! (-> obj current_level) (new 'global 'string 32 (new 'global 'string 32 "")))
    (set! (-> obj current_checkpoint) (new 'global 'string 32 (new 'global 'string 32 "")))
    (set! (-> obj on_zoomer?) 0)
    (set! (-> obj just_spawned?) 0)
    (set! (-> obj cell_count) 0)
    (set! (-> obj buzzer_count) 0)
    (set! (-> obj money_count) 0)
    (set! (-> obj death_count) 0)

  ;; task update
    (set! (-> obj has_task_update?) 0)
    (set! (-> obj task_name) (new 'global 'string 32 (new 'global 'string 32 "")))
    (set! (-> obj task_status) (new 'global 'string 32 (new 'global 'string 32 "unknown")))

  ;; buzzer update
    (set! (-> obj has_buzzer_update?) 0)
    (set! (-> obj buzzer_id) 0)
    (set! (-> obj buzzer_parent_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))

  ;; money update
    (set! (-> obj has_money_update?) 0)
    (set! (-> obj money_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj money_parent_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))

  ;; crate update
    (set! (-> obj has_crate_update?) 0)
    (set! (-> obj crate_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj crate_type) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj crate_amount) 0)

  ;; eco update
    (set! (-> obj has_eco_update?) 0)
    (set! (-> obj eco_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj eco_parent_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))

  ;; shared update data
    (set! (-> obj collectable_level_name) (new 'global 'string 32 (new 'global 'string 32 "none")))
    obj
    )
  )


(deftype game-levels-info (structure)
 ((has_level_update?    int32)
 
  (level0_name   string)
  (level0_status string)

  (level1_name   string)
  (level1_status string)
  )
  :pack-me
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new game-levels-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj has_level_update?) 0)
    (set! (-> obj level0_name) (new 'global 'string 32 (new 'global 'string 32 "")))
    (set! (-> obj level0_status) (new 'global 'string 32 (new 'global 'string 32 "")))

    (set! (-> obj level1_name) (new 'global 'string 32 (new 'global 'string 32 "")))
    (set! (-> obj level1_status) (new 'global 'string 32 (new 'global 'string 32 "")))
    obj
    )
  )


(deftype task-info (structure)
 ((task   game-task)
  (status task-status)
  )
  :pack-me
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new task-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj status) (task-status invalid))
    obj
    )
  )


(deftype money-info (structure)
 ((has_update? symbol)
  (ename    string)
  (parent_ename   string)
  (level_name   string)
  )
  :pack-me
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new money-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj has_update?) #f)
    (set! (-> obj ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj parent_ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj level_name) (new 'global 'string 32 (new 'global 'string 32 "none")))
    obj
    )
  )


(deftype crate-info (structure)
 ((has_update? symbol)
  (ename    string)
  (type   string)
  (amount   int32)
  (level_name   string)
  )
  :pack-me
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new crate-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj has_update?) #f)
    (set! (-> obj ename) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj type) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj level_name) (new 'global 'string 32 (new 'global 'string 32 "none")))
    (set! (-> obj amount) 0)
    obj
    )
  )


(deftype multiplayer-info (structure)
 ((player_num           int32)
  (players    remote-player-info MAX_MULTIPLAYER_COUNT :inline)
  )
  (:methods
    (new (symbol type) _type_ 0)
    )
  )

(defmethod new multiplayer-info ((allocation symbol) (type-to-make type))
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj player_num) -1)
    (dotimes (idx MAX_MULTIPLAYER_COUNT)
      (set! (-> obj players idx username) (new 'global 'string MAX_USERNAME_LEN (new 'global 'string MAX_USERNAME_LEN "")))
      )
    obj
    )
  )
